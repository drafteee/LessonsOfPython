1) language -> interpretator -> Cpython vm-> byte code
2) differences in py2 and py3
3) python math functions
4) a,b,c = 1, 2, 3
5) https://stackoverflow.com/questions/39983695/what-is-truthy-and-falsy-how-is-it-different-from-true-and-false

6) jupyter notebook
7) @classmethod 
Методы класса принимают класс в качестве параметра, который принято обозначать как cls. Он указывает на класс ToyClass, а не на объект этого класса. При декларации методов этого вида используется декоратор classmethod.
Методы класса привязаны к самому классу, а не его экземпляру. Они могут менять состояние класса, что отразится на всех объектах этого класса, но не могут менять конкретный объект.

8)Кстати, это не бесплатно - обращение к квалифицированному имени каждый раз создаёт дополнительный опкод LOAD_ATTR. Поэтому любители выжать максимум производительности (ну бывает полезно в глубоком цикле) используют такой трюк:
# медленно
l = []
for i in range(100500):
    l.append(i)
# чуть быстрее )))
push = l.append
for i in range(100500):
    push(i)

9) множественное наследование етсь
10) MRO, берутся свойства у родителей, которые ближе к нашему классу и который класс идет сначала в наследовании (A, B)
11) set is unique items
12) del func() удалил из памяти, но если на эту функцию ссылается еще кто-то, то у тех будет доступна функция

func1 = func
del func - not available
func1() - OK

13)зачем нужны генераторы(yield)?
 Она работает подобно return, потому что возвращает значение. Разница в том, что сохраняется состояние функции. В следующий раз, когда вызывается функция, выполнение продолжается с того места, где оно было остановлено, с теми же значениями переменных, что и перед yield.

 14) 